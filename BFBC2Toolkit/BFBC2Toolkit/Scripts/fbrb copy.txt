import logging
import os
import sys
import gzip
import tempfile
from io import BytesIO
from struct import pack, unpack

# packing parameters
compressionlevel = 1
packtmpfile = 1
unpacktmpfile = 0

unpackfolder = ""
packfolder = ""

BUFFSIZE = 1000000  # buffer when writing the fbrb archive


def grabstring(dump, offset):
    result = []
    while dump[offset] != 0:
        result.append(chr(dump[offset]))
        offset += 1
    return "".join(result)


def makeint(num):
    return pack(">I", num)


def readint(dump, pos):
    return unpack(">I", dump[pos:pos + 4])[0]


dic = dict(
    swfmovie='SwfMovie', dx10pixelshader='Dx10PixelShader', havokphysicsdata='HavokPhysicsData',
    treemeshset='TreeMeshSet', terrainheightfield='TerrainHeightfield', itexture='ITexture',
    animtreeinfo='AnimTreeInfo', irradiancevolume='IrradianceVolume', visualterrain='VisualTerrain',
    skinnedmeshset='SkinnedMeshSet', dx10vertexshader='Dx10VertexShader', aimanimation='AimAnimation',
    occludermesh='OccluderMesh', dx9shaderdatabase='Dx9ShaderDatabase', wave='Wave', sootmesh='SootMesh',
    terrainmaterialmap='TerrainMaterialMap', rigidmeshset='RigidMeshSet', compositemeshset='CompositeMeshSet',
    watermesh='WaterMesh', visualwater='VisualWater', dx9vertexshader='Dx9VertexShader',
    dx9pixelshader='Dx9PixelShader', dx11shaderdatabase='Dx11ShaderDatabase', dx11pixelshader='Dx11PixelShader',
    grannymodel='GrannyModel', ragdollresource='RagdollResource', grannyanimation='GrannyAnimation',
    weathersystem='WeatherSystem', dx11vertexshader='Dx11VertexShader', terrain='Terrain',
    impulseresponse='ImpulseResponse', binkmemory='BinkMemory', deltaanimation='DeltaAnimation',
    dx10shaderdatabase='Dx10ShaderDatabase', meshdata='MeshData', xenonpixelshader='XenonPixelShader',
    xenonvertexshader='XenonVertexShader', xenonshaderdatabase='XenonShaderDatabase', xenontexture='XenonTexture',
    ps3pixelshader='Ps3PixelShader', ps3vertexshader='Ps3VertexShader', ps3shaderdatabase='Ps3ShaderDatabase',
    ps3texture='Ps3Texture', pathdatadefinition='PathDataDefinition', nonres='<non-resource>', dbx='<non-resource>',
    dbxdeleted='*deleted*', resdeleted='*deleted*', bin='<non-resource>', dbmanifest='<non-resource>'
)


def packer(sourcefolder, targetfile="", compressionlevel=compressionlevel, tmpfile=1):
    sourcefolder = lp(sourcefolder)
    if not os.path.isdir(sourcefolder) or not sourcefolder.endswith(" FbRB"):
        return

    print(sourcefolder[4:])
    toplevellength = len(sourcefolder) + 1

    if not targetfile:
        targetfile = sourcefolder[:-5] + ".fbrb"
    else:
        targetfile = lp(targetfile) + ".fbrb"

    strings = b""
    extdic = {}
    entries = b""
    numofentries = 0
    payloadoffset = 0

    s2 = tempfile.TemporaryFile() if tmpfile else BytesIO()
    zippy2 = gzip.GzipFile(fileobj=s2, mode="wb", compresslevel=compressionlevel, filename="") if compressionlevel else None

    for dir0, dirs, files in os.walk(sourcefolder):
        dir0 += "\\"
        for f in files:
            rawfilename, extension = os.path.splitext(f)
            extension = extension[1:].lower()
            if extension not in dic:
                continue
            ext = dic[extension]
            numofentries += 1

            if extension == "dbxdeleted":
                filepath = dir0.replace("\\", "/")[toplevellength:] + f[:-7] + "\x00"
            elif extension not in ("dbx", "bin", "dbmanifest"):
                filepath = dir0.replace("\\", "/")[toplevellength:] + rawfilename + ".res\x00"
            else:
                filepath = dir0.replace("\\", "/")[toplevellength:] + f + "\x00"

            stringoffset = makeint(len(strings))
            strings += filepath.encode("utf-8")

            filelength = os.path.getsize(dir0 + f)
            deleteflag = b"\x00\x00\x00\x00" if filelength == 0 else b"\x00\x01\x00\x00"

            if ext in extdic:
                extpos = extdic[ext]
            else:
                extpos = len(strings)
                extdic[ext] = extpos
                strings += ext.encode("utf-8") + b"\x00"

            entries += stringoffset + deleteflag + makeint(payloadoffset) + 2 * makeint(filelength) + makeint(extpos)
            payloadoffset += filelength

            with open(dir0 + f, "rb") as f1:
                data = f1.read()
                if compressionlevel:
                    zippy2.write(data)
                else:
                    s2.write(data)

    zippedflag = b"\x01" if compressionlevel else b"\x00"
    if compressionlevel:
        zippy2.close()

    part1 = b"\x00\x00\x00\x02" + makeint(len(strings)) + strings + makeint(numofentries) + entries + zippedflag + makeint(payloadoffset)
    s1 = BytesIO()
    zippy = gzip.GzipFile(fileobj=s1, mode="wb", compresslevel=1)
    zippy.write(part1)
    zippy.close()
    output = s1.getvalue()
    s1.close()

    with open(targetfile, "wb") as out:
        s2.seek(0)
        out.write(b"FbRB" + makeint(len(output)) + output)
        while True:
            buff = s2.read(BUFFSIZE)
            if buff:
                out.write(buff)
            else:
                break
    s2.close()


def unpacker(sourcefilename, targetfolder="", tmpfile=0):
    sourcefilename = lp(sourcefilename)
    if not sourcefilename.lower().endswith(".fbrb"):
        return

    with open(sourcefilename, "rb") as f:
        if f.read(4) != b"FbRB":
            print("Invalid FbRB file")
            return

        print(os.path.basename(sourcefilename))
        if not targetfolder:
            targetfolder = sourcefilename[:-5] + " FbRB\\"
        else:
            targetfolder = lp(targetfolder) + " FbRB\\"

        if not os.path.isdir(targetfolder):
            os.makedirs(targetfolder)

        cut = unpack(">I", f.read(4))[0]
        part1 = BytesIO(f.read(cut))
        part2 = tempfile.TemporaryFile() if tmpfile else BytesIO(f.read())
        if tmpfile:
            part2.seek(0)

    zippy = gzip.GzipFile(mode="rb", fileobj=part1)
    zippy2 = gzip.GzipFile(mode="rb", fileobj=part2)

    dump = zippy.read()
    part1.close()
    zippy.close()

    zipped = 0 if dump[-5] == 0 else 1
    strlen = readint(dump, 4)
    numentries = readint(dump, strlen + 8)

    for i in range(numentries):
        filenameoffset = readint(dump, strlen + 12 + i * 24)
        payloadoffset = readint(dump, strlen + 20 + i * 24)
        payloadlen = readint(dump, strlen + 24 + i * 24)
        extensionoffset = readint(dump, strlen + 32 + i * 24)

        folder, filename = os.path.split(grabstring(dump, filenameoffset + 8))
        name, ending = os.path.splitext(filename)
        extension = grabstring(dump, extensionoffset + 8).lower()

        if extension == "*deleted*":
            ending = ".dbxdeleted" if ending == ".dbx" else ".resdeleted"
        elif extension == "<non-resource>" and ending == ".res":
            ending = ".nonres"
        elif extension != "<non-resource>":
            ending = "." + extension

        finalpath = os.path.join(targetfolder, folder.replace("/", "\\"))
        if folder != "":
            finalpath += "\\"
        if not os.path.isdir(finalpath):
            os.makedirs(finalpath)

        outpath = os.path.join(finalpath, name + ending)
        with open(outpath, "wb") as out:
            if zipped:
                zippy2.seek(payloadoffset)
                out.write(zippy2.read(payloadlen))
            else:
                part2.seek(payloadoffset)
                out.write(part2.read(payloadlen))

    zippy2.close()
    part2.close()


def